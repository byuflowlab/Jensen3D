!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (develop) - 17 Dec 2020 10:03
!
!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (develop) - 17 Dec 2020 10:03
!
!  Differentiation of jensenwake in reverse (adjoint) mode:
!   gradient     of useful results: wtvelocity
!   with respect to varying inputs: turbinexw wtvelocity turbineyw
!   RW status of diff variables: turbinexw:out wtvelocity:in-zero
!                turbineyw:out
SUBROUTINE JENSENWAKE_BV(nturbines, nctpoints, turbinexw, turbinexwb, &
& turbineyw, turbineywb, rotordiameter, alpha, bound_angle, ct_curve_ct&
& , ct_curve_wind_speed, use_ct_curve, relaxationfactor, windspeed, &
& wtvelocityb, nbdirs)
  !USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  INTEGER, INTENT(IN) :: nturbines, nctpoints
  REAL(dp), INTENT(IN) :: relaxationfactor, bound_angle, alpha, &
& windspeed
  REAL(dp), DIMENSION(nturbines), INTENT(IN) :: turbinexw, turbineyw, &
& rotordiameter
  REAL(dp), DIMENSION(nbdirs, nturbines), intent(out) :: turbinexwb, turbineywb
  REAL(dp), DIMENSION(nctpoints), INTENT(IN) :: ct_curve_ct, &
& ct_curve_wind_speed
  LOGICAL, INTENT(IN) :: use_ct_curve
! out
  REAL(dp), DIMENSION(nturbines) :: wtvelocity
  REAL(dp), DIMENSION(nbdirs, nturbines) :: wtvelocityb
! local
  REAL(dp) :: loss, a
  REAL(dp), DIMENSION(nbdirs) :: lossb, ab
  REAL(dp) :: x, y, r
  REAL(dp), DIMENSION(nbdirs) :: xb
  REAL(dp), DIMENSION(nturbines) :: loss_array, ct_local, r0
  REAL(dp), DIMENSION(nbdirs, nturbines) :: loss_arrayb, ct_localb
  REAL(dp), DIMENSION(nturbines, nturbines) :: f_theta
  REAL(dp), DIMENSION(nbdirs, nturbines, nturbines) :: f_thetab
  REAL(dp), PARAMETER :: pi=3.141592653589793_dp
  INTEGER :: i, j
  INTRINSIC SUM, SQRT
  INTEGER :: nd
  REAL(dp) :: temp
  REAL(dp), DIMENSION(nbdirs) :: tempb
  INTEGER :: branch
  INTEGER :: nbdirs
  r0 = rotordiameter(:)/2.0_dp
  CALL GET_COSINE_FACTOR_ORIGINAL(nturbines, turbinexw, turbineyw, r0, &
&                           bound_angle, relaxationfactor, f_theta)
!print *, "using Jensen Fortran"
  DO i=1,nturbines
    DO j=1,nturbines
      x = turbinexw(i) - turbinexw(j)
      IF (x .GT. 0.) THEN
        IF (use_ct_curve) THEN
          CALL PUSHREAL8(a)
          CALL CT_TO_AXIAL_IND_FUNC(ct_local(j), a)
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHREAL8(a)
          a = 1.0_dp/3.0_dp
          CALL PUSHCONTROL1B(1)
        END IF
        CALL PUSHREAL8(loss_array(j))
        loss_array(j) = 2.0_dp*a*(r0(j)/(r0(j)+alpha*x))**2*f_theta(j, i&
&         )
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHREAL8(loss_array(j))
        loss_array(j) = 0.0_dp
        CALL PUSHCONTROL1B(0)
      END IF
    END DO
    loss = SQRT(SUM(loss_array**2))
    wtvelocity(i) = (1.0-loss)*windspeed
! update thrust coefficient for turbI
    CALL PUSHREAL8(ct_local(i))
    CALL LINEAR_INTERPOLATION(nctpoints, ct_curve_wind_speed, &
&                       ct_curve_ct, wtvelocity(i), ct_local(i))
  END DO
  turbinexwb(:, :) = 0.0_8
  loss_arrayb(:, :) = 0.0_8
  f_thetab(:, :, :) = 0.0_8
  ct_localb(:, :) = 0.0_8
  DO i=nturbines,1,-1
    CALL POPREAL8(ct_local(i))
    CALL LINEAR_INTERPOLATION_BV(nctpoints, ct_curve_wind_speed, &
&                          ct_curve_ct, wtvelocity(i), wtvelocityb(1, i)&
&                          , ct_local(i), ct_localb(1, i), nbdirs)
    ct_localb(:, i) = 0.0_8
    DO nd=1,nbdirs
      lossb(nd) = -(windspeed*wtvelocityb(nd, i))
      wtvelocityb(nd, i) = 0.0_8
      IF (.NOT.SUM(loss_array**2) .EQ. 0.0) loss_arrayb(nd, :) = &
&         loss_arrayb(nd, :) + 2*loss_array*lossb(nd)/(2.0*SQRT(SUM(&
&         loss_array**2)))
    END DO
    DO j=nturbines,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL8(loss_array(j))
        DO nd=1,nbdirs
          loss_arrayb(nd, j) = 0.0_8
        END DO
        xb(:) = 0.0_8
      ELSE
        x = turbinexw(i) - turbinexw(j)
        CALL POPREAL8(loss_array(j))
        temp = r0(j) + alpha*x
        DO nd=1,nbdirs
          tempb(nd) = r0(j)**2*2.0_dp*loss_arrayb(nd, j)/temp**2
          loss_arrayb(nd, j) = 0.0_8
          ab(nd) = f_theta(j, i)*tempb(nd)
          f_thetab(nd, j, i) = f_thetab(nd, j, i) + a*tempb(nd)
          xb(nd) = -(alpha*2*a*f_theta(j, i)*tempb(nd)/temp)
        END DO
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREAL8(a)
          CALL CT_TO_AXIAL_IND_FUNC_BV(ct_local(j), ct_localb(1, j), a, &
&                                ab, nbdirs)
        ELSE
          CALL POPREAL8(a)
        END IF
      END IF
      DO nd=1,nbdirs
        turbinexwb(nd, i) = turbinexwb(nd, i) + xb(nd)
        turbinexwb(nd, j) = turbinexwb(nd, j) - xb(nd)
      END DO
    END DO
  END DO
  CALL GET_COSINE_FACTOR_ORIGINAL_BV(nturbines, turbinexw, turbinexwb, &
&                              turbineyw, turbineywb, r0, bound_angle, &
&                              relaxationfactor, f_theta, f_thetab, &
&                              nbdirs)
  wtvelocityb(:, :) = 0.0_8
END SUBROUTINE JENSENWAKE_BV
! subroutine DirPower(nTurbines, turbineX, turbineY, wind_dir_deg, wind_speed, turb_diam, &
!                     &turb_ci, turb_co, rated_ws, rated_pwr, relaxationFactor, pwrDir)
!     implicit none
!     ! define precision to be the standard for a double precision ! on local system
!     integer, parameter :: dp = kind(0.d0)
!     ! in
!     integer, intent(in) :: nTurbines
!     real(dp), intent(in) :: wind_dir_deg, wind_speed, turb_diam, turb_ci, turb_co, rated_ws, rated_pwr, relaxationFactor
!     real(dp), dimension(nTurbines), intent(in) :: turbineX, turbineY
!     ! out
!     real(dp), intent(out) :: pwrDir
!     ! local
!     real(dp), dimension(nTurbines) :: wind_speed_eff, turb_pwr
!     real(dp), dimension(nTurbines) :: turbineXw, turbineYw, loss
!     integer :: n
!     call WindFrame(nTurbines, wind_dir_deg, turbineX, turbineY, turbineXw, turbineYw)
!     call JensenWake(nTurbines, turbineXw, turbineYw, turb_diam, relaxationFactor, loss)
!     wind_speed_eff = wind_speed*(1.-loss)
!     do n = 1, nTurbines
!         if (turb_ci <= wind_speed_eff(n) .and. wind_speed_eff(n) < rated_ws) then
!             turb_pwr(n) = rated_pwr * ((wind_speed_eff(n)-turb_ci)/(rated_ws-turb_ci))**3
!         else if (rated_ws <= wind_speed_eff(n) .and. wind_speed_eff(n) < turb_co) then
!             turb_pwr(n) = rated_pwr
!         else
!             turb_pwr(n) = 0.0
!         end if
!     end do
!     pwrDir = sum(turb_pwr)
! end subroutine DirPower
! subroutine calcAEP(nTurbines, nDirections, turbineX, turbineY, wind_freq, wind_speed, wind_dir,&
!             &turb_diam, turb_ci, turb_co, rated_ws, rated_pwr, relaxationFactor, AEP)
!     implicit none
!     ! define precision to be the standard for a double precision ! on local system
!     integer, parameter :: dp = kind(0.d0)
!     ! in
!     integer, intent(in) :: nTurbines, nDirections
!     real(dp), intent(in) :: turb_diam, turb_ci, turb_co, rated_ws, rated_pwr, relaxationFactor
!     real(dp), dimension(nTurbines), intent(in) :: turbineX, turbineY
!     real(dp), dimension(nDirections), intent(in) :: wind_freq, wind_speed, wind_dir
!     ! out
!     real(dp), intent(out) :: AEP
!     ! local
!     real(dp), dimension(nDirections) :: pwr_produced
!     real(dp) :: hrs_per_year, pwrDir
!     integer :: i
!     do i = 1, nDirections
!         call DirPower(nTurbines, turbineX, turbineY, wind_dir(i), wind_speed(i), turb_diam, &
!                             &turb_ci, turb_co, rated_ws, rated_pwr, relaxationFactor, pwrDir)
!         pwr_produced(i) = pwrDir
!     end do
!     hrs_per_year = 365.*24.
!     AEP = hrs_per_year * (sum(wind_freq * pwr_produced))
!     AEP = AEP/1000000.0
! end subroutine calcAEP

!  Differentiation of get_cosine_factor_original in reverse (adjoint) mode:
!   gradient     of useful results: x f_theta
!   with respect to varying inputs: x y
SUBROUTINE GET_COSINE_FACTOR_ORIGINAL_BV(nturbines, x, xb, y, yb, r0, &
& bound_angle, relaxationfactor, f_theta, f_thetab, nbdirs)
  !USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
  INTEGER, PARAMETER :: dp=KIND(0.d0)
  INTEGER, INTENT(IN) :: nturbines
  REAL(dp), INTENT(IN) :: bound_angle, relaxationfactor
  REAL(dp), DIMENSION(nturbines), INTENT(IN) :: x, y, r0
  REAL(dp), DIMENSION(nbdirs, nturbines) :: xb, yb
  REAL(dp), PARAMETER :: pi=3.141592653589793_dp
  REAL(dp), DIMENSION(nturbines, nturbines) :: f_theta
  REAL(dp), DIMENSION(nbdirs, nturbines, nturbines) :: f_thetab
  REAL(dp) :: q, gamma, theta, z
  REAL(dp), DIMENSION(nbdirs) :: thetab
  INTEGER :: i, j
  INTRINSIC SIN
  INTRINSIC ATAN
  INTRINSIC COS
  INTEGER :: nd
  REAL(dp) :: temp
  REAL(dp) :: temp0
  REAL(dp), DIMENSION(nbdirs) :: tempb
  REAL(dp), DIMENSION(nbdirs) :: tempb0
  INTEGER :: branch
  INTEGER :: nbdirs
  q = pi/(bound_angle*pi/180.0)
  gamma = pi/2.0 - bound_angle*pi/180.0
  DO i=1,nturbines
    DO j=1,nturbines
      IF (x(i) .LT. x(j)) THEN
        CALL PUSHREAL8(z)
        z = relaxationfactor*r0(i)*SIN(gamma)/SIN(bound_angle*pi/180.0)
        CALL PUSHREAL8(theta)
        theta = ATAN((y(j)-y(i))/(x(j)-x(i)+z))
        IF (-(bound_angle*pi/180.0) .LT. theta .AND. theta .LT. &
&           bound_angle*pi/180.0) THEN
          CALL PUSHCONTROL2B(2)
        ELSE
          CALL PUSHCONTROL2B(1)
        END IF
      ELSE
        CALL PUSHCONTROL2B(0)
      END IF
    END DO
  END DO
  yb(:, :) = 0.0_8
  DO i=nturbines,1,-1
    DO j=nturbines,1,-1
      CALL POPCONTROL2B(branch)
      IF (branch .EQ. 0) THEN
        DO nd=1,nbdirs
          f_thetab(nd, i, j) = 0.0_8
        END DO
      ELSE
        IF (branch .EQ. 1) THEN
          DO nd=1,nbdirs
            f_thetab(nd, i, j) = 0.0_8
          END DO
          thetab(:) = 0.0_8
        ELSE
          DO nd=1,nbdirs
            thetab(nd) = -(q*SIN(q*theta)*f_thetab(nd, i, j)/2.)
            f_thetab(nd, i, j) = 0.0_8
          END DO
        END IF
        CALL POPREAL8(theta)
        temp = z + x(j) - x(i)
        temp0 = (y(j)-y(i))/temp
        CALL POPREAL8(z)
        DO nd=1,nbdirs
          tempb(nd) = thetab(nd)/(temp*(1.0+temp0**2))
          yb(nd, j) = yb(nd, j) + tempb(nd)
          yb(nd, i) = yb(nd, i) - tempb(nd)
          tempb0(nd) = -(temp0*tempb(nd))
          xb(nd, j) = xb(nd, j) + tempb0(nd)
          xb(nd, i) = xb(nd, i) - tempb0(nd)
        END DO
      END IF
    END DO
  END DO
END SUBROUTINE GET_COSINE_FACTOR_ORIGINAL_BV

!  Differentiation of ct_to_axial_ind_func in reverse (adjoint) mode:
!   gradient     of useful results: axial_induction ct
!   with respect to varying inputs: ct
! calculate axial induction from Ct
SUBROUTINE CT_TO_AXIAL_IND_FUNC_BV(ct, ctb, axial_induction, &
& axial_inductionb, nbdirs)
  !USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: ct
  REAL(dp), DIMENSION(nbdirs) :: ctb
! out
  REAL(dp) :: axial_induction
  REAL(dp), DIMENSION(nbdirs) :: axial_inductionb
  INTRINSIC SQRT
  INTEGER :: nd
  INTEGER :: nbdirs
! initialize axial induction to zero
! calculate axial induction
  IF (ct .GT. 0.96) THEN
    DO nd=1,nbdirs
      IF (.NOT.0.0203_dp - 0.6427_dp*(0.889_dp-ct) .EQ. 0.0) ctb(nd) = &
&         ctb(nd) + 0.6427_dp*axial_inductionb(nd)/(2.0*SQRT(0.0203_dp-&
&         0.6427_dp*(0.889_dp-ct)))
    END DO
  ELSE
    DO nd=1,nbdirs
      IF (.NOT.1.0_dp - ct .EQ. 0.0) ctb(nd) = ctb(nd) + 0.5_dp*&
&         axial_inductionb(nd)/(2.0*SQRT(1.0_dp-ct))
    END DO
  END IF
END SUBROUTINE CT_TO_AXIAL_IND_FUNC_BV

!  Differentiation of linear_interpolation in reverse (adjoint) mode:
!   gradient     of useful results: yval xval
!   with respect to varying inputs: xval
SUBROUTINE LINEAR_INTERPOLATION_BV(npoints, x, y, xval, xvalb, yval, &
& yvalb, nbdirs)
  !USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  INTEGER, INTENT(IN) :: npoints
  REAL(dp), DIMENSION(npoints), INTENT(IN) :: x, y
  REAL(dp), INTENT(IN) :: xval
  REAL(dp), DIMENSION(nbdirs) :: xvalb
! local
  INTEGER :: idx
  REAL(dp) :: x0, x1, y0, y1
! out
  REAL(dp) :: yval
  REAL(dp), DIMENSION(nbdirs) :: yvalb
  INTEGER :: nd
  INTEGER :: nbdirs
  IF (xval .GE. x(1)) THEN
    IF (xval .LE. x(npoints)) THEN
      idx = 1
      DO WHILE (xval .GT. x(idx) .AND. idx .LE. npoints)
        idx = idx + 1
      END DO
      idx = idx - 1
      x0 = x(idx)
      x1 = x(idx+1)
      y0 = y(idx)
      y1 = y(idx+1)
      DO nd=1,nbdirs
        xvalb(nd) = xvalb(nd) + (y1-y0)*yvalb(nd)/(x1-x0)
      END DO
    END IF
  END IF
END SUBROUTINE LINEAR_INTERPOLATION_BV


